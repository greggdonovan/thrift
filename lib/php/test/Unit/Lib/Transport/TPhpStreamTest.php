<?php

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

namespace Test\Thrift\Unit\Lib\Transport;

use phpmock\phpunit\PHPMock;
use PHPUnit\Framework\Attributes\DataProvider;
use PHPUnit\Framework\TestCase;
use Thrift\Exception\TException;
use Thrift\Transport\TPhpStream;

class TPhpStreamTest extends TestCase
{
    use PHPMock;

    /**
     * Helper method to properly evaluate PHPUnit constraints when comparing expected vs actual args.
     */
    private function assertArgsMatch(array $expected, array $actual): void
    {
        // Only check expected arguments (ignore extra optional parameters added by php-mock)
        foreach ($expected as $i => $exp) {
            if ($exp instanceof \PHPUnit\Framework\Constraint\Constraint) {
                $this->assertThat($actual[$i], $exp);
            } else {
                $this->assertEquals($exp, $actual[$i]);
            }
        }
    }

    #[DataProvider('fopenDataProvider')]
    public function testOpen(
        $mode,
        $sapiName,
        $fopenParams,
        $fopenResult,
        $expectedException,
        $expectedExceptionMessage,
        $expectedExceptionCode
    ) {
        #due to the running tests in separate process we could not open stream in data provider, so we need to do it here
        foreach ($fopenResult as $num => $result) {
            $fopenResult[$num] = $result ? fopen(...$result) : $result;
        }

        $this->getFunctionMock('Thrift\Transport', 'php_sapi_name')
             ->expects(!empty($sapiName) ? $this->once() : $this->never())
             ->willReturn($sapiName);

        $fopenCallIndex = 0;
        $this->getFunctionMock('Thrift\Transport', 'fopen')
             ->expects($this->exactly(count($fopenResult)))
             ->willReturnCallback(function (...$args) use (&$fopenCallIndex, $fopenParams, $fopenResult) {
                 $this->assertArgsMatch($fopenParams[$fopenCallIndex], $args);
                 return $fopenResult[$fopenCallIndex++];
             });

        if ($expectedException) {
            $this->expectException($expectedException);
            $this->expectExceptionMessage($expectedExceptionMessage);
            $this->expectExceptionCode($expectedExceptionCode);
        }

        $transport = new TPhpStream($mode);
        $transport->open();
    }

    public static function fopenDataProvider()
    {
        yield 'readCli' => [
            'mode' => TPhpStream::MODE_R,
            'sapiName' => 'cli',
            'fopenParams' => [['php://stdin', 'r']],
            'fopenResult' => [['php://temp', 'r']],
            'expectedException' => null,
            'expectedExceptionMessage' => '',
            'expectedExceptionCode' => 0,
        ];
        yield 'readNotCli' => [
            'mode' => TPhpStream::MODE_R,
            'sapiName' => 'apache',
            'fopenParams' => [['php://input', 'r']],
            'fopenResult' => [['php://temp', 'r']],
            'expectedException' => null,
            'expectedExceptionMessage' => '',
            'expectedExceptionCode' => 0,
        ];
        yield 'write' => [
            'mode' => TPhpStream::MODE_W,
            'sapiName' => '',
            'fopenParams' => [['php://output', 'w']],
            'fopenResult' => [['php://temp', 'w']],
            'expectedException' => null,
            'expectedExceptionMessage' => '',
            'expectedExceptionCode' => 0,
        ];
        yield 'read and write' => [
            'mode' => TPhpStream::MODE_R | TPhpStream::MODE_W,
            'sapiName' => 'cli',
            'fopenParams' => [['php://stdin', 'r'], ['php://output', 'w']],
            'fopenResult' => [['php://temp', 'r'], ['php://temp', 'w']],
            'expectedException' => null,
            'expectedExceptionMessage' => '',
            'expectedExceptionCode' => 0,
        ];
        yield 'read exception' => [
            'mode' => TPhpStream::MODE_R,
            'sapiName' => 'cli',
            'fopenParams' => [['php://stdin', 'r']],
            'fopenResult' => [false],
            'expectedException' => TException::class,
            'expectedExceptionMessage' => 'TPhpStream: Could not open php://input',
            #should depend on php_sapi_name result
            'expectedExceptionCode' => 0,
        ];
        yield 'write exception' => [
            'mode' => TPhpStream::MODE_W,
            'sapiName' => '',
            'fopenParams' => [['php://output', 'w']],
            'fopenResult' => [false],
            'expectedException' => TException::class,
            'expectedExceptionMessage' => 'TPhpStream: Could not open php://output',
            'expectedExceptionCode' => 0,
        ];
    }

    #[DataProvider('closeDataProvider')]
    public function testClose(
        $mode,
        $fopenParams,
        $fopenResult
    ) {
        #due to the running tests in separate process we could not open stream in data provider, so we need to do it here
        foreach ($fopenResult as $num => $result) {
            $fopenResult[$num] = $result ? fopen(...$result) : $result;
        }

        $fopenCallIndex = 0;
        $this->getFunctionMock('Thrift\Transport', 'fopen')
             ->expects($this->exactly(count($fopenParams)))
             ->willReturnCallback(function (...$args) use (&$fopenCallIndex, $fopenParams, $fopenResult) {
                 $this->assertArgsMatch($fopenParams[$fopenCallIndex], $args);
                 return $fopenResult[$fopenCallIndex++];
             });

        $this->getFunctionMock('Thrift\Transport', 'fclose')
             ->expects($this->exactly(count($fopenParams)))
             ->with(
                 $this->callback(function ($stream) {
                     return is_resource($stream);
                 })
             )
             ->willReturn(true);

        $transport = new TPhpStream($mode);
        $transport->open();
        $this->assertTrue($transport->isOpen());

        $transport->close();
        $this->assertFalse($transport->isOpen());
    }

    public static function closeDataProvider()
    {
        $read = ['php://temp', 'r'];
        $write = ['php://temp', 'w'];
        yield 'read' => [
            'mode' => TPhpStream::MODE_R,
            'fopenParams' => [['php://stdin', 'r']],
            'fopenResult' => [$read],
        ];
        yield 'write' => [
            'mode' => TPhpStream::MODE_W,
            'fopenParams' => [['php://output', 'w']],
            'fopenResult' => [$write],
        ];
        yield 'read and write' => [
            'mode' => TPhpStream::MODE_R | TPhpStream::MODE_W,
            'fopenParams' => [['php://stdin', 'r'], ['php://output', 'w']],
            'fopenResult' => [$read, $write],
        ];
    }

    #[DataProvider('readDataProvider')]
    public function testRead(
        $freadResult,
        $expectedResult,
        $expectedException,
        $expectedExceptionMessage,
        $expectedExceptionCode
    ) {
        $this->getFunctionMock('Thrift\Transport', 'fread')
             ->expects($this->once())
             ->with(self::anything(), 5)
             ->willReturn($freadResult);

        if ($expectedException) {
            $this->expectException($expectedException);
            $this->expectExceptionMessage($expectedExceptionMessage);
            $this->expectExceptionCode($expectedExceptionCode);
        }

        $transport = new TPhpStream(TPhpStream::MODE_R);
        $this->assertEquals($expectedResult, $transport->read(5));
    }

    public static function readDataProvider()
    {
        yield 'success' => [
            'freadResult' => '12345',
            'expectedResult' => '12345',
            'expectedException' => null,
            'expectedExceptionMessage' => '',
            'expectedExceptionCode' => 0,
        ];
        yield 'empty' => [
            'freadResult' => '',
            'expectedResult' => '',
            'expectedException' => TException::class,
            'expectedExceptionMessage' => 'TPhpStream: Could not read 5 bytes',
            'expectedExceptionCode' => 0,
        ];
        yield 'false' => [
            'freadResult' => false,
            'expectedResult' => false,
            'expectedException' => TException::class,
            'expectedExceptionMessage' => 'TPhpStream: Could not read 5 bytes',
            'expectedExceptionCode' => 0,
        ];
    }

    #[DataProvider('writeDataProvider')]
    public function testWrite(
        $buf,
        $fwriteParams,
        $fwriteResult,
        $expectedException,
        $expectedExceptionMessage,
        $expectedExceptionCode
    ) {
        $fwriteCallIndex = 0;
        $this->getFunctionMock('Thrift\Transport', 'fwrite')
             ->expects($this->exactly(count($fwriteParams)))
             ->willReturnCallback(function (...$args) use (&$fwriteCallIndex, $fwriteParams, $fwriteResult) {
                 $this->assertArgsMatch($fwriteParams[$fwriteCallIndex], $args);
                 return $fwriteResult[$fwriteCallIndex++];
             });

        if ($expectedException) {
            $this->expectException($expectedException);
            $this->expectExceptionMessage($expectedExceptionMessage);
            $this->expectExceptionCode($expectedExceptionCode);
        }

        $transport = new TPhpStream(TPhpStream::MODE_W);
        $transport->write($buf);
    }

    public static function writeDataProvider()
    {
        yield 'success' => [
            'buf' => '12345',
            'fwriteParams' => [[self::anything(), '12345']],
            'fwriteResult' => [5],
            'expectedException' => null,
            'expectedExceptionMessage' => '',
            'expectedExceptionCode' => 0,
        ];
        yield 'several iteration' => [
            'buf' => '1234567890',
            'fwriteParams' => [[self::anything(), '1234567890'], [self::anything(), '67890']],
            'fwriteResult' => [5, 5],
            'expectedException' => null,
            'expectedExceptionMessage' => '',
            'expectedExceptionCode' => 0,
        ];
        yield 'fail' => [
            'buf' => '1234567890',
            'fwriteParams' => [[self::anything(), '1234567890']],
            'fwriteResult' => [false],
            'expectedException' => TException::class,
            'expectedExceptionMessage' => 'TPhpStream: Could not write 10 bytes',
            'expectedExceptionCode' => 0,
        ];
    }

    public function testFlush()
    {
        $this->getFunctionMock('Thrift\Transport', 'fflush')
             ->expects($this->once());

        $transport = new TPhpStream(TPhpStream::MODE_R);
        $transport->flush();
    }
}
